@prefix : <https://cube.link/shape/standalone-constraint-constraint#> .
@prefix dash: <http://datashapes.org/dash#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix schema: <http://schema.org/> .
@prefix sh: <http://www.w3.org/ns/shacl#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix cube: <https://cube.link/> .
@prefix meta: <https://cube.link/meta/> .
@prefix qudt: <http://qudt.org/schema/qudt/> .

#
# This is the bare minimal SHACL shape for validating a Cube Constraint.
# All Cube Constraints should pass this validation.
#

:ObservationConstraintShape
    a sh:NodeShape ;
    sh:targetClass cube:Constraint ;
    sh:property [
        # we assume at least 3 dimensions, otherwise we would have an empty list of dimensions
        # one for cube:observedBy, one for rdf:type and at least one cube dimension
        sh:path sh:property ;
        sh:minCount 3 ;
        sh:message "cube:Constraint needs at least a certain amount of sh:properties"
    ] ;
    sh:property
        [
            sh:path sh:property ;
            sh:node :PropertyPath ;
            sh:message "a sh:path is needed on a property" ;
        ] ,
        [
            sh:path sh:property ;
            sh:node :PropertyWithName ;
            sh:message "needs a schema:name" ;
        ] ,
        [
            sh:path sh:property ;
            sh:node :PropertyNameType ;
            sh:message "schema:name needs to be a xsd:string or a rdf:langString" ;
        ] ,
        [
            sh:path sh:property ;
            sh:node :PropertyWithType ;
            sh:message "needs a sh:datatype, sh:nodeKind or sh:datatype within sh:or (...)" ;
        ] ,
        [
            sh:path sh:property ;
            sh:node :PropertyScaleType ;
            sh:message "If qudt:scaleType is used it needs to be within ( qudt:IntervalScale qudt:NominalScale qudt:EnumerationScale qudt:RatioScale qudt:OrdinalScale )" ;
        ] ,
        [
            sh:path sh:property ;
            sh:node :PropertyRange ;
        ] ,
        [
            sh:path sh:property ;
            sh:node :PropertyInList ;
            sh:message "sh:in needs to be a list" ;
        ] ,
        [
            sh:path sh:property ;
            sh:node :DimensionRelation ;
        ] ,
        [
            sh:path sh:property ;
            sh:node [
                sh:path qudt:unit ;
                sh:equals qudt:hasUnit ;
            ] ;
            sh:severity sh:Warning ;
            sh:message "The use of qudt:unit is deprecated, please use qudt:hasUnit instead" ;
        ] ;
	sh:property [
        sh:path sh:closed;
        sh:hasValue true;
    ] ;
    sh:property [
        sh:path meta:inHierarchy;
        sh:node :Hierarchy;
        sh:message "meta:inHierarchy does not validate"
    ] ;
    .

:PropertyPath a sh:NodeShape ;
    sh:property [
        sh:path sh:path;
        sh:minCount 1;
        sh:maxCount 1;
    ] ;
.

:PropertyWithName a sh:NodeShape ;
    sh:or(
        [
            sh:path schema:name;
            sh:minCount 1;
        ]
        [
            sh:path sh:path;
            sh:in (rdf:type cube:observedBy);
        ]
    );
.

:PropertyNameType a sh:NodeShape ;
    sh:property [
        sh:path schema:name;
        sh:or ( [ sh:datatype xsd:string ] [ sh:datatype rdf:langString ] ) ;
    ];
.

:PropertyWithType a sh:NodeShape ;
    sh:or(
        [
            sh:path sh:datatype;
            sh:minCount 1;
        ]
        [
            sh:path sh:nodeKind;
            sh:minCount 1;
        ]
        [
            sh:path sh:or;
            sh:minCount 1;
            sh:node :listnode ;
            sh:property [
                sh:path ( [ sh:zeroOrMorePath rdf:rest ] rdf:first ) ; # all list elements
                sh:property [ sh:path sh:datatype ; sh:minCount 1 ] ; # have at least one datatype
            ]
        ]
    );
.

:PropertyInList a sh:NodeShape ;
    sh:property [
        sh:path sh:in;
        sh:node :listnode ;
    ];
.

:PropertyScaleType a sh:NodeShape ;
    sh:property [
        sh:path qudt:scaleType;
        sh:in (qudt:IntervalScale qudt:NominalScale qudt:EnumerationScale qudt:RatioScale qudt:OrdinalScale) ;
        sh:maxCount 1;
    ];
.

:PropertyRange a sh:NodeShape ;
    sh:property [
        sh:path sh:minInclusive;
        sh:nodeType sh:Literal;
        sh:message "sh:minInclusive needs to be a literal"
    ];
    sh:property [
        sh:path sh:maxInclusive;
        sh:nodeType sh:Literal;
        sh:message "sh:maxInclusive needs to be a literal"
    ];
    sh:property [
        sh:path sh:minCount;
        sh:minCount 1 ;
        sh:maxCount 1 ;
        sh:hasValue 1 ;
        sh:message "sh:minCount needs to be 1" ;
    ] , [
        sh:path sh:maxCount;
        sh:minCount 1 ;
        sh:maxCount 1 ;
        sh:hasValue 1 ;
        sh:message "sh:maxCount needs to be 1" ;
    ] ;
.

:DimensionRelation a sh:NodeShape ;
    sh:property [
        sh:path meta:dimensionRelation;
        sh:property [
            sh:path meta:relatesTo;
            sh:nodeKind sh:IRI ;
            sh:minCount 1;
            sh:message "meta:dimensionRelation requires at least one meta:relatesTo";
        ] ;
    ] ;
.


# Testing proper rdf:list construction

:restvalue sh:targetObjectsOf rdf:rest ;
    sh:message "rdf:rest value must be a list node or rdf:nil";
    sh:or ([ sh:node :listnode ] [ sh:hasValue rdf:nil ])
.

:listnode sh:targetSubjectsOf rdf:first, rdf:rest ;
    sh:property [ sh:path rdf:first ; sh:minCount 1 ; sh:maxCount 1 ;
        sh:message "list node needs exactly one rdf:first" ] ;
    sh:property [ sh:path rdf:rest ; sh:minCount 1 ; sh:maxCount 1 ;
        sh:message "list node needs exactly one rdf:rest" ] ;
    sh:closed true ;
    sh:ignoredProperties (rdf:type) .


:inversepathnode a sh:NodeShape ;
    sh:property [
        sh:path sh:inversePath;
        sh:nodeKind sh:IRI;
        sh:minCount 1;
        sh:maxCount 1;
        sh:message "nextInHierarchy requires sh:path to be IRI or [ sh:inversePath ... ]"
    ] .

:NextInHierarchy a sh:NodeShape ;
    sh:property [
        sh:path sh:path;
        sh:minCount 1;
        sh:maxCount 1;
        sh:message "nextInHierarchy requires exactly one sh:path"
    ],
    [
        sh:path schema:name;
        sh:minCount 1;
        sh:message "nextInHierarchy requires schema:name"
    ],
    [
        sh:path sh:targetClass;
        sh:nodeKind sh:IRI;
        sh:message "meta:nextInHierarchy/sh:targetClass must be an IRI"
    ],
    [
        sh:path meta:nextInHierarchy;
        sh:node :NextInHierarchy ;
        sh:severity sh:Info;
        sh:message "nextInHierarchy can have nested nodes"
    ] ;
    sh:or (
        [
            sh:path sh:path;
	        sh:nodeKind sh:IRI;
            sh:message "nextInHierarchy requires sh:path to be IRI or [ sh:inversePath ... ]"
        ]
        [
            sh:path sh:path;
            sh:nodeKind sh:BlankNode;
            sh:node :inversepathnode;
            sh:message "nextInHierarchy requires sh:path to be IRI or [ sh:inversePath ... ]"
        ]
    )
    .

:Hierarchy a sh:NodeShape ;
    sh:targetClass meta:Hierarchy ;
    sh:property [
        sh:path meta:hierarchyRoot;
        sh:minCount 1;
        sh:nodeKind sh:IRI;
        sh:message "inHierarchy requires hierarchyRoot";
    ],
    [
        sh:path schema:name;
        sh:minCount 1;
        sh:message "inHierarchy requires schema:name"
    ],
    [
        sh:path meta:nextInHierarchy;
	    sh:node :NextInHierarchy;
        sh:minCount 1;
        sh:message "inHierarchy requires a conform nextInHierarchy"
    ] .
